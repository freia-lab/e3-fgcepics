// ../../sw/kt/fgcepics/fgcudpSup/src/classes/class_63_params.cpp - This file is automatically generated by `parser/Output/EPICS/asynDriver/FGC_handler.pm`  DO NOT EDIT

#include <alarm.h>
#include <string>

#include <asynPortDriver.h>

#include "pub_data.h"
#include "param_utils.h"
#include "class_base_params.h"
#include "classes/63/class_63_params.h"
#include "classes/63/sub_defsyms.h"
#include "classes/63/sub_defconst.h"

#define NAME_BUFFER_LEN 256

void Class63::create_class_params(asynPortDriver * drv)
{
    ClassHandler::create_class_params(drv);
    int dev_tag = get_tag();
    char name_buffer[NAME_BUFFER_LEN];

#define CREATE_PARAM(id, type, name) do { \
    snprintf(name_buffer, NAME_BUFFER_LEN, "%d_%s", dev_tag, (name)); \
    drv->createParam(name_buffer, (type), (id)); \
    } while(0)

    CREATE_PARAM(&param_id[0  ], asynParamOctet        , "ST_FAULTS__STR");
    CREATE_PARAM(&param_id[1  ], asynParamUInt32Digital, "ST_FAULTS__RAW");
    CREATE_PARAM(&param_id[2  ], asynParamOctet        , "ST_WARNINGS__STR");
    CREATE_PARAM(&param_id[3  ], asynParamUInt32Digital, "ST_WARNINGS__RAW");
    CREATE_PARAM(&param_id[4  ], asynParamOctet        , "ST_LATCHED__STR");
    CREATE_PARAM(&param_id[5  ], asynParamUInt32Digital, "ST_LATCHED__RAW");
    CREATE_PARAM(&param_id[6  ], asynParamOctet        , "ST_UNLATCHED__STR");
    CREATE_PARAM(&param_id[7  ], asynParamUInt32Digital, "ST_UNLATCHED__RAW");
    CREATE_PARAM(&param_id[8  ], asynParamOctet        , "STATE_PLL__STR");
    CREATE_PARAM(&param_id[9  ], asynParamUInt32Digital, "STATE_PLL__RAW");
    CREATE_PARAM(&param_id[10 ], asynParamOctet        , "STATE_OP__STR");
    CREATE_PARAM(&param_id[11 ], asynParamUInt32Digital, "STATE_OP__RAW");
    CREATE_PARAM(&param_id[12 ], asynParamOctet        , "STATE_VS__STR");
    CREATE_PARAM(&param_id[13 ], asynParamUInt32Digital, "STATE_VS__RAW");
    CREATE_PARAM(&param_id[14 ], asynParamOctet        , "STATE_PC__STR");
    CREATE_PARAM(&param_id[15 ], asynParamUInt32Digital, "STATE_PC__RAW");
    CREATE_PARAM(&param_id[16 ], asynParamOctet        , "ST_ADC_A__STR");
    CREATE_PARAM(&param_id[17 ], asynParamUInt32Digital, "ST_ADC_A__RAW");
    CREATE_PARAM(&param_id[18 ], asynParamOctet        , "ST_ADC_B__STR");
    CREATE_PARAM(&param_id[19 ], asynParamUInt32Digital, "ST_ADC_B__RAW");
    CREATE_PARAM(&param_id[20 ], asynParamOctet        , "ST_ADC_C__STR");
    CREATE_PARAM(&param_id[21 ], asynParamUInt32Digital, "ST_ADC_C__RAW");
    CREATE_PARAM(&param_id[22 ], asynParamOctet        , "ST_ADC_D__STR");
    CREATE_PARAM(&param_id[23 ], asynParamUInt32Digital, "ST_ADC_D__RAW");
    CREATE_PARAM(&param_id[24 ], asynParamOctet        , "ST_DCCT_A__STR");
    CREATE_PARAM(&param_id[25 ], asynParamUInt32Digital, "ST_DCCT_A__RAW");
    CREATE_PARAM(&param_id[26 ], asynParamOctet        , "ST_DCCT_B__STR");
    CREATE_PARAM(&param_id[27 ], asynParamUInt32Digital, "ST_DCCT_B__RAW");
    CREATE_PARAM(&param_id[28 ], asynParamInt32        , "I_ERR_MA__INT");
    CREATE_PARAM(&param_id[29 ], asynParamInt32        , "I_DIFF_MA__INT");
    CREATE_PARAM(&param_id[30 ], asynParamInt32        , "EVENT_GROUP__INT");
    CREATE_PARAM(&param_id[31 ], asynParamInt32        , "I_EARTH_PCNT__INT");
    CREATE_PARAM(&param_id[32 ], asynParamFloat64      , "I_REF__FLOAT");
    CREATE_PARAM(&param_id[33 ], asynParamFloat64      , "I_MEAS__FLOAT");
    CREATE_PARAM(&param_id[34 ], asynParamFloat64      , "V_REF__FLOAT");
    CREATE_PARAM(&param_id[35 ], asynParamFloat64      , "V_MEAS__FLOAT");

    drv->setStringParam(      param_id[0  ], "");
    drv->setUIntDigitalParam( param_id[1  ], 0, 0xFFFF);
    drv->setStringParam(      param_id[2  ], "");
    drv->setUIntDigitalParam( param_id[3  ], 0, 0xFFFF);
    drv->setStringParam(      param_id[4  ], "");
    drv->setUIntDigitalParam( param_id[5  ], 0, 0xFFFF);
    drv->setStringParam(      param_id[6  ], "");
    drv->setUIntDigitalParam( param_id[7  ], 0, 0xFFFF);
    drv->setStringParam(      param_id[8  ], "");
    drv->setUIntDigitalParam( param_id[9  ], 0, 0xFFFF);
    drv->setStringParam(      param_id[10 ], "");
    drv->setUIntDigitalParam( param_id[11 ], 0, 0xFFFF);
    drv->setStringParam(      param_id[12 ], "");
    drv->setUIntDigitalParam( param_id[13 ], 0, 0xFFFF);
    drv->setStringParam(      param_id[14 ], "");
    drv->setUIntDigitalParam( param_id[15 ], 0, 0xFFFF);
    drv->setStringParam(      param_id[16 ], "");
    drv->setUIntDigitalParam( param_id[17 ], 0, 0xFFFF);
    drv->setStringParam(      param_id[18 ], "");
    drv->setUIntDigitalParam( param_id[19 ], 0, 0xFFFF);
    drv->setStringParam(      param_id[20 ], "");
    drv->setUIntDigitalParam( param_id[21 ], 0, 0xFFFF);
    drv->setStringParam(      param_id[22 ], "");
    drv->setUIntDigitalParam( param_id[23 ], 0, 0xFFFF);
    drv->setStringParam(      param_id[24 ], "");
    drv->setUIntDigitalParam( param_id[25 ], 0, 0xFFFF);
    drv->setStringParam(      param_id[26 ], "");
    drv->setUIntDigitalParam( param_id[27 ], 0, 0xFFFF);
    drv->setIntegerParam(     param_id[28 ], 0);
    drv->setIntegerParam(     param_id[29 ], 0);
    drv->setIntegerParam(     param_id[30 ], 0);
    drv->setIntegerParam(     param_id[31 ], 0);
    drv->setDoubleParam(      param_id[32 ], 0);
    drv->setDoubleParam(      param_id[33 ], 0);
    drv->setDoubleParam(      param_id[34 ], 0);
    drv->setDoubleParam(      param_id[35 ], 0);
};



void Class63::update_class_params(asynPortDriver * drv, Pub_data & pub_data)
{
    ClassHandler::update_class_params(drv, pub_data);
    int dev_id   = get_id();

    //Check if class 63 data is valid
    if(
        !(pub_data.status[dev_id].data_status & FGC_DATA_VALID)  ||
        !(pub_data.status[dev_id].data_status & FGC_CLASS_VALID) ||
        (pub_data.status[dev_id].class_id != class_id)
    )
    {
        for(int i = 0; i < ASYN_PARAMS_63; i++)
        {
            drv->setParamStatus(param_id[i], asynSuccess); // Force callback
            drv->setParamStatus(param_id[i], asynParamUndefined);
        }
        return;
    }

    struct fgc63_stat & stats = pub_data.status[dev_id].class_data.c63;

    // Bit mask symbol parsing
    std::string st_faults_str    = conv_fgc_flags(ntohs(stats.st_faults)      , sym_names_63_flt);
    std::string st_warnings_str  = conv_fgc_flags(ntohs(stats.st_warnings)    , sym_names_63_wrn);
    std::string st_latched_str   = conv_fgc_flags(ntohs(stats.st_latched)     , sym_names_63_lat);
    std::string st_unlatched_str = conv_fgc_flags(ntohs(stats.st_unlatched)   , sym_names_63_unl);
    std::string st_adc_a_str     = conv_fgc_flags(stats.st_adc_a              , sym_names_63_adc_status);
    std::string st_adc_b_str     = conv_fgc_flags(stats.st_adc_b              , sym_names_63_adc_status);
    std::string st_adc_c_str     = conv_fgc_flags(stats.st_adc_c              , sym_names_63_adc_status);
    std::string st_adc_d_str     = conv_fgc_flags(stats.st_adc_d              , sym_names_63_adc_status);
    std::string st_dcct_a_str    = conv_fgc_flags(stats.st_dcct_a             , sym_names_63_dcct);
    std::string st_dcct_b_str    = conv_fgc_flags(stats.st_dcct_b             , sym_names_63_dcct);

    int32_t st_faults_raw    = ntohs(stats.st_faults);
    int32_t st_warnings_raw  = ntohs(stats.st_warnings);
    int32_t st_latched_raw   = ntohs(stats.st_latched);
    int32_t st_unlatched_raw = ntohs(stats.st_unlatched);
    int32_t st_adc_a_raw     = stats.st_adc_a;
    int32_t st_adc_b_raw     = stats.st_adc_b;
    int32_t st_adc_c_raw     = stats.st_adc_c;
    int32_t st_adc_d_raw     = stats.st_adc_d;
    int32_t st_dcct_a_raw    = stats.st_dcct_a;
    int32_t st_dcct_b_raw    = stats.st_dcct_b;

    // Enum symbol parsing
    std::string state_pll_str    = conv_fgc_enum(stats.state_pll , sym_names_63_pll);
    std::string state_op_str     = conv_fgc_enum(stats.state_op  , sym_names_63_op);
    std::string state_vs_str     = conv_fgc_enum(stats.state_vs  , sym_names_63_vs);
    std::string state_pc_str     = conv_fgc_enum(stats.state_pc  , sym_names_63_pc);

    int32_t state_pll_raw    = stats.state_pll;
    int32_t state_op_raw     = stats.state_op;
    int32_t state_vs_raw     = stats.state_vs;
    int32_t state_pc_raw     = stats.state_pc;

    // Remaining values parsing, casted int32_t or float
    int32_t i_err_ma_int     = ntohs(stats.i_err_ma);
    int32_t i_diff_ma_int    = ntohs(stats.i_diff_ma);
    int32_t event_group_int  = stats.event_group;
    int32_t i_earth_pcnt_int = stats.i_earth_pcnt;
    float   i_ref_float      = ntohf(stats.i_ref);
    float   i_meas_float     = ntohf(stats.i_meas);
    float   v_ref_float      = ntohf(stats.v_ref);
    float   v_meas_float     = ntohf(stats.v_meas);

    drv->setStringParam(      param_id[0  ], st_faults_str);
    drv->setUIntDigitalParam( param_id[1  ], st_faults_raw, 0xFFFF);
    drv->setStringParam(      param_id[2  ], st_warnings_str);
    drv->setUIntDigitalParam( param_id[3  ], st_warnings_raw, 0xFFFF);
    drv->setStringParam(      param_id[4  ], st_latched_str);
    drv->setUIntDigitalParam( param_id[5  ], st_latched_raw, 0xFFFF);
    drv->setStringParam(      param_id[6  ], st_unlatched_str);
    drv->setUIntDigitalParam( param_id[7  ], st_unlatched_raw, 0xFFFF);
    drv->setStringParam(      param_id[8  ], state_pll_str);
    drv->setUIntDigitalParam( param_id[9  ], state_pll_raw, 0xFFFF);
    drv->setStringParam(      param_id[10 ], state_op_str);
    drv->setUIntDigitalParam( param_id[11 ], state_op_raw, 0xFFFF);
    drv->setStringParam(      param_id[12 ], state_vs_str);
    drv->setUIntDigitalParam( param_id[13 ], state_vs_raw, 0xFFFF);
    drv->setStringParam(      param_id[14 ], state_pc_str);
    drv->setUIntDigitalParam( param_id[15 ], state_pc_raw, 0xFFFF);
    drv->setStringParam(      param_id[16 ], st_adc_a_str);
    drv->setUIntDigitalParam( param_id[17 ], st_adc_a_raw, 0xFFFF);
    drv->setStringParam(      param_id[18 ], st_adc_b_str);
    drv->setUIntDigitalParam( param_id[19 ], st_adc_b_raw, 0xFFFF);
    drv->setStringParam(      param_id[20 ], st_adc_c_str);
    drv->setUIntDigitalParam( param_id[21 ], st_adc_c_raw, 0xFFFF);
    drv->setStringParam(      param_id[22 ], st_adc_d_str);
    drv->setUIntDigitalParam( param_id[23 ], st_adc_d_raw, 0xFFFF);
    drv->setStringParam(      param_id[24 ], st_dcct_a_str);
    drv->setUIntDigitalParam( param_id[25 ], st_dcct_a_raw, 0xFFFF);
    drv->setStringParam(      param_id[26 ], st_dcct_b_str);
    drv->setUIntDigitalParam( param_id[27 ], st_dcct_b_raw, 0xFFFF);
    drv->setIntegerParam(     param_id[28 ], i_err_ma_int);
    drv->setIntegerParam(     param_id[29 ], i_diff_ma_int);
    drv->setIntegerParam(     param_id[30 ], event_group_int);
    drv->setIntegerParam(     param_id[31 ], i_earth_pcnt_int);
    drv->setDoubleParam(      param_id[32 ], i_ref_float);
    drv->setDoubleParam(      param_id[33 ], i_meas_float);
    drv->setDoubleParam(      param_id[34 ], v_ref_float);
    drv->setDoubleParam(      param_id[35 ], v_meas_float);

    // Update parameter values
    // Note: In order to trigger the callbacks execution, an actual change in
    //       value or status has to happen.
    //       This forces the asynDriver flag 'modified' to be updated.
    //       Otherwise, the timestamp update is not guaranteed to occur...
    //       Hope this will be fixed in a future asynDriver release.

    // Validate params
    for(int i = 0; i < ASYN_PARAMS_63; i++)
    {
        drv->setParamStatus(param_id[i], asynParamUndefined); // Force callback
        drv->setParamStatus(param_id[i], asynSuccess);
    }

};



void Class63::invalidate_class_params(asynPortDriver * drv)
{
    ClassHandler::invalidate_class_params(drv);

    for(int i = 0; i < ASYN_PARAMS_63; i++)
    {
        drv->setParamStatus(param_id[i], asynTimeout);
    }
}



// End of file: ../../sw/kt/fgcepics/fgcudpSup/src/classes/class_63_params.cpp
