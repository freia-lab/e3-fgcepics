// ../../sw/lib/fgceth/fgcepics/fgcudpSup/src/classes/class_62_params.cpp - This file is automatically generated by `parser/Output/EPICS/asynDriver/FGC_handler.pm`  DO NOT EDIT

#include <alarm.h>
#include <string>

#include <asynPortDriver.h>

#include "pub_data.h"
#include "param_utils.h"
#include "class_base_params.h"
#include "classes/62/class_62_params.h"
#include "classes/62/sub_defsyms.h"
#include "classes/62/sub_defconst.h"



void Class62::create_class_params(asynPortDriver * drv)
{
    ClassHandler::create_class_params(drv);
    int dev_addr = get_addr();
    drv->createParam(dev_addr, "ST_FAULTS"     , asynParamOctet  , &param_id[0]);
    drv->createParam(dev_addr, "ST_WARNINGS"   , asynParamOctet  , &param_id[1]);
    drv->createParam(dev_addr, "ST_LATCHED"    , asynParamOctet  , &param_id[2]);
    drv->createParam(dev_addr, "ST_UNLATCHED"  , asynParamOctet  , &param_id[3]);
    drv->createParam(dev_addr, "STATE_PLL"     , asynParamOctet  , &param_id[4]);
    drv->createParam(dev_addr, "STATE_OP"      , asynParamOctet  , &param_id[5]);
    drv->createParam(dev_addr, "STATE_VS"      , asynParamOctet  , &param_id[6]);
    drv->createParam(dev_addr, "STATE_PC"      , asynParamOctet  , &param_id[7]);
    drv->createParam(dev_addr, "ST_ADC_A"      , asynParamOctet  , &param_id[8]);
    drv->createParam(dev_addr, "ST_ADC_B"      , asynParamOctet  , &param_id[9]);
    drv->createParam(dev_addr, "ST_ADC_C"      , asynParamOctet  , &param_id[10]);
    drv->createParam(dev_addr, "ST_ADC_D"      , asynParamOctet  , &param_id[11]);
    drv->createParam(dev_addr, "ST_DCCT_A"     , asynParamOctet  , &param_id[12]);
    drv->createParam(dev_addr, "I_EARTH_PCNT"  , asynParamInt32  , &param_id[13]);
    drv->createParam(dev_addr, "I_ERR_MA"      , asynParamInt32  , &param_id[14]);
    drv->createParam(dev_addr, "I_REF"         , asynParamFloat64, &param_id[15]);
    drv->createParam(dev_addr, "I_MEAS"        , asynParamFloat64, &param_id[16]);
    drv->createParam(dev_addr, "V_MEAS"        , asynParamFloat64, &param_id[17]);
    drv->createParam(dev_addr, "V_CAPA"        , asynParamFloat64, &param_id[18]);
};



void Class62::update_class_params(asynPortDriver * drv, Pub_data & pub_data)
{
    ClassHandler::update_class_params(drv, pub_data);
    int dev_id   = get_id();    int dev_addr = get_addr();
    //Check if class 62 data is valid
    if(
        !(pub_data.status[dev_id].data_status & FGC_DATA_VALID)  ||
        !(pub_data.status[dev_id].data_status & FGC_CLASS_VALID) ||
        (pub_data.status[dev_id].class_id != class_id)
    )
    {
        for(int i = 0; i < ASYN_PARAMS_62; i++)
        {
            drv->setParamStatus(dev_addr, param_id[i], asynParamUndefined);
        }
        return;
    }

    struct fgc62_stat & stats = pub_data.status[dev_id].class_data.c62;

    // Bit mask symbol parsing
    std::string st_faults_str    = conv_fgc_flags(ntohs(stats.st_faults)      , sym_names_62_flt);
    std::string st_warnings_str  = conv_fgc_flags(ntohs(stats.st_warnings)    , sym_names_62_wrn);
    std::string st_latched_str   = conv_fgc_flags(ntohs(stats.st_latched)     , sym_names_62_lat);
    std::string st_unlatched_str = conv_fgc_flags(ntohs(stats.st_unlatched)   , sym_names_62_unl);
    std::string st_adc_a_str     = conv_fgc_flags(stats.st_adc_a              , sym_names_62_adc_status);
    std::string st_adc_b_str     = conv_fgc_flags(stats.st_adc_b              , sym_names_62_adc_status);
    std::string st_adc_c_str     = conv_fgc_flags(stats.st_adc_c              , sym_names_62_adc_status);
    std::string st_adc_d_str     = conv_fgc_flags(stats.st_adc_d              , sym_names_62_adc_status);
    std::string st_dcct_a_str    = conv_fgc_flags(stats.st_dcct_a             , sym_names_62_dcct);

    // Enum symbol parsing
    std::string state_pll_str    = conv_fgc_enum(stats.state_pll , sym_names_62_pll);
    std::string state_op_str     = conv_fgc_enum(stats.state_op  , sym_names_62_op);
    std::string state_vs_str     = conv_fgc_enum(stats.state_vs  , sym_names_62_vs);
    std::string state_pc_str     = conv_fgc_enum(stats.state_pc  , sym_names_62_pc);

    // Remaining values parsing, casted int32_t or float
    int32_t i_earth_pcnt_int = stats.i_earth_pcnt;
    int32_t i_err_ma_int     = ntohs(stats.i_err_ma);
    float   i_ref_float      = ntohf(stats.i_ref);
    float   i_meas_float     = ntohf(stats.i_meas);
    float   v_meas_float     = ntohf(stats.v_meas);
    float   v_capa_float     = ntohf(stats.v_capa);

    // Update parameter values
    // Note: Before setting the actual value, 'mod()'' has to be used to
    //       force the asynDriver flag 'modified' to be updated.
    //       Otherwise, the timestamp update is not guaranteed to occur...
    //       Hope this will be fixed in a future asynDriver release.
    drv->setStringParam( dev_addr, param_id[0] , mod(st_faults_str));
    drv->setStringParam( dev_addr, param_id[0] , st_faults_str);

    drv->setStringParam( dev_addr, param_id[1] , mod(st_warnings_str));
    drv->setStringParam( dev_addr, param_id[1] , st_warnings_str);

    drv->setStringParam( dev_addr, param_id[2] , mod(st_latched_str));
    drv->setStringParam( dev_addr, param_id[2] , st_latched_str);

    drv->setStringParam( dev_addr, param_id[3] , mod(st_unlatched_str));
    drv->setStringParam( dev_addr, param_id[3] , st_unlatched_str);

    drv->setStringParam( dev_addr, param_id[4] , mod(state_pll_str));
    drv->setStringParam( dev_addr, param_id[4] , state_pll_str);

    drv->setStringParam( dev_addr, param_id[5] , mod(state_op_str));
    drv->setStringParam( dev_addr, param_id[5] , state_op_str);

    drv->setStringParam( dev_addr, param_id[6] , mod(state_vs_str));
    drv->setStringParam( dev_addr, param_id[6] , state_vs_str);

    drv->setStringParam( dev_addr, param_id[7] , mod(state_pc_str));
    drv->setStringParam( dev_addr, param_id[7] , state_pc_str);

    drv->setStringParam( dev_addr, param_id[8] , mod(st_adc_a_str));
    drv->setStringParam( dev_addr, param_id[8] , st_adc_a_str);

    drv->setStringParam( dev_addr, param_id[9] , mod(st_adc_b_str));
    drv->setStringParam( dev_addr, param_id[9] , st_adc_b_str);

    drv->setStringParam( dev_addr, param_id[10], mod(st_adc_c_str));
    drv->setStringParam( dev_addr, param_id[10], st_adc_c_str);

    drv->setStringParam( dev_addr, param_id[11], mod(st_adc_d_str));
    drv->setStringParam( dev_addr, param_id[11], st_adc_d_str);

    drv->setStringParam( dev_addr, param_id[12], mod(st_dcct_a_str));
    drv->setStringParam( dev_addr, param_id[12], st_dcct_a_str);

    drv->setIntegerParam(dev_addr, param_id[13], mod(i_earth_pcnt_int));
    drv->setIntegerParam(dev_addr, param_id[13], i_earth_pcnt_int);

    drv->setIntegerParam(dev_addr, param_id[14], mod(i_err_ma_int));
    drv->setIntegerParam(dev_addr, param_id[14], i_err_ma_int);

    drv->setDoubleParam( dev_addr, param_id[15], mod(i_ref_float));
    drv->setDoubleParam( dev_addr, param_id[15], i_ref_float);

    drv->setDoubleParam( dev_addr, param_id[16], mod(i_meas_float));
    drv->setDoubleParam( dev_addr, param_id[16], i_meas_float);

    drv->setDoubleParam( dev_addr, param_id[17], mod(v_meas_float));
    drv->setDoubleParam( dev_addr, param_id[17], v_meas_float);

    drv->setDoubleParam( dev_addr, param_id[18], mod(v_capa_float));
    drv->setDoubleParam( dev_addr, param_id[18], v_capa_float);

    // Validate params
    for(int i = 0; i < ASYN_PARAMS_62; i++)
    {
        drv->setParamStatus(dev_addr, param_id[i], asynSuccess);
    }

};



void Class62::invalidate_class_params(asynPortDriver * drv)
{
    ClassHandler::invalidate_class_params(drv);
    int dev_addr = get_addr();
    for(int i = 0; i < ASYN_PARAMS_62; i++)
    {
        drv->setParamStatus(dev_addr, param_id[i], asynTimeout);
    }
}



// End of file: ../../sw/lib/fgceth/fgcepics/fgcudpSup/src/classes/class_62_params.cpp
