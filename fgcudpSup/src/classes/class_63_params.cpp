// ../../sw/kt/fgcepics/fgcudpSup/src/classes/class_63_params.cpp - This file is automatically generated by `parser/Output/EPICS/asynDriver/FGC_handler.pm`  DO NOT EDIT

#include <alarm.h>
#include <string>

#include <asynPortDriver.h>

#include "pub_data.h"
#include "param_utils.h"
#include "class_base_params.h"
#include "classes/63/class_63_params.h"
#include "classes/63/sub_defsyms.h"
#include "classes/63/sub_defconst.h"

#define NAME_BUFFER_LEN 256

void Class63::create_class_params(asynPortDriver * drv)
{
    ClassHandler::create_class_params(drv);
    int dev_tag = get_tag();
    char name_buffer[NAME_BUFFER_LEN];

    snprintf(name_buffer, NAME_BUFFER_LEN, "%d_%s", dev_tag, "ST_FAULTS");
    drv->createParam(name_buffer, asynParamOctet  , &param_id[0]);
    snprintf(name_buffer, NAME_BUFFER_LEN, "%d_%s", dev_tag, "ST_WARNINGS");
    drv->createParam(name_buffer, asynParamOctet  , &param_id[1]);
    snprintf(name_buffer, NAME_BUFFER_LEN, "%d_%s", dev_tag, "ST_LATCHED");
    drv->createParam(name_buffer, asynParamOctet  , &param_id[2]);
    snprintf(name_buffer, NAME_BUFFER_LEN, "%d_%s", dev_tag, "ST_UNLATCHED");
    drv->createParam(name_buffer, asynParamOctet  , &param_id[3]);
    snprintf(name_buffer, NAME_BUFFER_LEN, "%d_%s", dev_tag, "STATE_PLL");
    drv->createParam(name_buffer, asynParamOctet  , &param_id[4]);
    snprintf(name_buffer, NAME_BUFFER_LEN, "%d_%s", dev_tag, "STATE_OP");
    drv->createParam(name_buffer, asynParamOctet  , &param_id[5]);
    snprintf(name_buffer, NAME_BUFFER_LEN, "%d_%s", dev_tag, "STATE_VS");
    drv->createParam(name_buffer, asynParamOctet  , &param_id[6]);
    snprintf(name_buffer, NAME_BUFFER_LEN, "%d_%s", dev_tag, "STATE_PC");
    drv->createParam(name_buffer, asynParamOctet  , &param_id[7]);
    snprintf(name_buffer, NAME_BUFFER_LEN, "%d_%s", dev_tag, "ST_ADC_A");
    drv->createParam(name_buffer, asynParamOctet  , &param_id[8]);
    snprintf(name_buffer, NAME_BUFFER_LEN, "%d_%s", dev_tag, "ST_ADC_B");
    drv->createParam(name_buffer, asynParamOctet  , &param_id[9]);
    snprintf(name_buffer, NAME_BUFFER_LEN, "%d_%s", dev_tag, "ST_ADC_C");
    drv->createParam(name_buffer, asynParamOctet  , &param_id[10]);
    snprintf(name_buffer, NAME_BUFFER_LEN, "%d_%s", dev_tag, "ST_ADC_D");
    drv->createParam(name_buffer, asynParamOctet  , &param_id[11]);
    snprintf(name_buffer, NAME_BUFFER_LEN, "%d_%s", dev_tag, "ST_DCCT_A");
    drv->createParam(name_buffer, asynParamOctet  , &param_id[12]);
    snprintf(name_buffer, NAME_BUFFER_LEN, "%d_%s", dev_tag, "ST_DCCT_B");
    drv->createParam(name_buffer, asynParamOctet  , &param_id[13]);
    snprintf(name_buffer, NAME_BUFFER_LEN, "%d_%s", dev_tag, "I_ERR_MA");
    drv->createParam(name_buffer, asynParamInt32  , &param_id[14]);
    snprintf(name_buffer, NAME_BUFFER_LEN, "%d_%s", dev_tag, "I_DIFF_MA");
    drv->createParam(name_buffer, asynParamInt32  , &param_id[15]);
    snprintf(name_buffer, NAME_BUFFER_LEN, "%d_%s", dev_tag, "EVENT_GROUP");
    drv->createParam(name_buffer, asynParamInt32  , &param_id[16]);
    snprintf(name_buffer, NAME_BUFFER_LEN, "%d_%s", dev_tag, "I_EARTH_PCNT");
    drv->createParam(name_buffer, asynParamInt32  , &param_id[17]);
    snprintf(name_buffer, NAME_BUFFER_LEN, "%d_%s", dev_tag, "I_REF");
    drv->createParam(name_buffer, asynParamFloat64, &param_id[18]);
    snprintf(name_buffer, NAME_BUFFER_LEN, "%d_%s", dev_tag, "I_MEAS");
    drv->createParam(name_buffer, asynParamFloat64, &param_id[19]);
    snprintf(name_buffer, NAME_BUFFER_LEN, "%d_%s", dev_tag, "V_REF");
    drv->createParam(name_buffer, asynParamFloat64, &param_id[20]);
    snprintf(name_buffer, NAME_BUFFER_LEN, "%d_%s", dev_tag, "V_MEAS");
    drv->createParam(name_buffer, asynParamFloat64, &param_id[21]);

    drv->setStringParam( param_id[0] , "");
    drv->setStringParam( param_id[1] , "");
    drv->setStringParam( param_id[2] , "");
    drv->setStringParam( param_id[3] , "");
    drv->setStringParam( param_id[4] , "");
    drv->setStringParam( param_id[5] , "");
    drv->setStringParam( param_id[6] , "");
    drv->setStringParam( param_id[7] , "");
    drv->setStringParam( param_id[8] , "");
    drv->setStringParam( param_id[9] , "");
    drv->setStringParam( param_id[10], "");
    drv->setStringParam( param_id[11], "");
    drv->setStringParam( param_id[12], "");
    drv->setStringParam( param_id[13], "");
    drv->setIntegerParam(param_id[14], 0);
    drv->setIntegerParam(param_id[15], 0);
    drv->setIntegerParam(param_id[16], 0);
    drv->setIntegerParam(param_id[17], 0);
    drv->setDoubleParam( param_id[18], 0);
    drv->setDoubleParam( param_id[19], 0);
    drv->setDoubleParam( param_id[20], 0);
    drv->setDoubleParam( param_id[21], 0);
};



void Class63::update_class_params(asynPortDriver * drv, Pub_data & pub_data)
{
    ClassHandler::update_class_params(drv, pub_data);
    int dev_id   = get_id();

    //Check if class 63 data is valid
    if(
        !(pub_data.status[dev_id].data_status & FGC_DATA_VALID)  ||
        !(pub_data.status[dev_id].data_status & FGC_CLASS_VALID) ||
        (pub_data.status[dev_id].class_id != class_id)
    )
    {
        for(int i = 0; i < ASYN_PARAMS_63; i++)
        {
            drv->setParamStatus(param_id[i], asynSuccess); // Force callback
            drv->setParamStatus(param_id[i], asynParamUndefined);
        }
        return;
    }

    struct fgc63_stat & stats = pub_data.status[dev_id].class_data.c63;

    // Bit mask symbol parsing
    std::string st_faults_str    = conv_fgc_flags(ntohs(stats.st_faults)      , sym_names_63_flt);
    std::string st_warnings_str  = conv_fgc_flags(ntohs(stats.st_warnings)    , sym_names_63_wrn);
    std::string st_latched_str   = conv_fgc_flags(ntohs(stats.st_latched)     , sym_names_63_lat);
    std::string st_unlatched_str = conv_fgc_flags(ntohs(stats.st_unlatched)   , sym_names_63_unl);
    std::string st_adc_a_str     = conv_fgc_flags(stats.st_adc_a              , sym_names_63_adc_status);
    std::string st_adc_b_str     = conv_fgc_flags(stats.st_adc_b              , sym_names_63_adc_status);
    std::string st_adc_c_str     = conv_fgc_flags(stats.st_adc_c              , sym_names_63_adc_status);
    std::string st_adc_d_str     = conv_fgc_flags(stats.st_adc_d              , sym_names_63_adc_status);
    std::string st_dcct_a_str    = conv_fgc_flags(stats.st_dcct_a             , sym_names_63_dcct);
    std::string st_dcct_b_str    = conv_fgc_flags(stats.st_dcct_b             , sym_names_63_dcct);

    // Enum symbol parsing
    std::string state_pll_str    = conv_fgc_enum(stats.state_pll , sym_names_63_pll);
    std::string state_op_str     = conv_fgc_enum(stats.state_op  , sym_names_63_op);
    std::string state_vs_str     = conv_fgc_enum(stats.state_vs  , sym_names_63_vs);
    std::string state_pc_str     = conv_fgc_enum(stats.state_pc  , sym_names_63_pc);

    // Remaining values parsing, casted int32_t or float
    int32_t i_err_ma_int     = ntohs(stats.i_err_ma);
    int32_t i_diff_ma_int    = ntohs(stats.i_diff_ma);
    int32_t event_group_int  = stats.event_group;
    int32_t i_earth_pcnt_int = stats.i_earth_pcnt;
    float   i_ref_float      = ntohf(stats.i_ref);
    float   i_meas_float     = ntohf(stats.i_meas);
    float   v_ref_float      = ntohf(stats.v_ref);
    float   v_meas_float     = ntohf(stats.v_meas);

    drv->setStringParam( param_id[0] , st_faults_str);
    drv->setStringParam( param_id[1] , st_warnings_str);
    drv->setStringParam( param_id[2] , st_latched_str);
    drv->setStringParam( param_id[3] , st_unlatched_str);
    drv->setStringParam( param_id[4] , state_pll_str);
    drv->setStringParam( param_id[5] , state_op_str);
    drv->setStringParam( param_id[6] , state_vs_str);
    drv->setStringParam( param_id[7] , state_pc_str);
    drv->setStringParam( param_id[8] , st_adc_a_str);
    drv->setStringParam( param_id[9] , st_adc_b_str);
    drv->setStringParam( param_id[10], st_adc_c_str);
    drv->setStringParam( param_id[11], st_adc_d_str);
    drv->setStringParam( param_id[12], st_dcct_a_str);
    drv->setStringParam( param_id[13], st_dcct_b_str);
    drv->setIntegerParam(param_id[14], i_err_ma_int);
    drv->setIntegerParam(param_id[15], i_diff_ma_int);
    drv->setIntegerParam(param_id[16], event_group_int);
    drv->setIntegerParam(param_id[17], i_earth_pcnt_int);
    drv->setDoubleParam( param_id[18], i_ref_float);
    drv->setDoubleParam( param_id[19], i_meas_float);
    drv->setDoubleParam( param_id[20], v_ref_float);
    drv->setDoubleParam( param_id[21], v_meas_float);

    // Update parameter values
    // Note: In order to trigger the callbacks execution, an actual change in
    //       value or status has to happen.
    //       This forces the asynDriver flag 'modified' to be updated.
    //       Otherwise, the timestamp update is not guaranteed to occur...
    //       Hope this will be fixed in a future asynDriver release.

    // Validate params
    for(int i = 0; i < ASYN_PARAMS_63; i++)
    {
        drv->setParamStatus(param_id[i], asynParamUndefined); // Force callback
        drv->setParamStatus(param_id[i], asynSuccess);
    }

};



void Class63::invalidate_class_params(asynPortDriver * drv)
{
    ClassHandler::invalidate_class_params(drv);

    for(int i = 0; i < ASYN_PARAMS_63; i++)
    {
        drv->setParamStatus(param_id[i], asynTimeout);
    }
}



// End of file: ../../sw/kt/fgcepics/fgcudpSup/src/classes/class_63_params.cpp
